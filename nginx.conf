worker_processes auto;

events {
    worker_connections 1024;
}

http {
    lua_shared_dict site_previews 10m; # Shared memory to store mappings of subdomains to IPs and domains

    resolver 1.1.1.1;  # Google Public DNS
    # Alternatively, you can use your local DNS server or another public DNS server

    # Cloudflare IP ranges
    set_real_ip_from 173.245.48.0/20;
    set_real_ip_from 103.21.244.0/22;
    set_real_ip_from 103.22.200.0/22;
    set_real_ip_from 103.31.4.0/22;
    set_real_ip_from 141.101.64.0/18;
    set_real_ip_from 108.162.192.0/18;
    set_real_ip_from 190.93.240.0/20;
    set_real_ip_from 188.114.96.0/20;
    set_real_ip_from 197.234.240.0/22;
    set_real_ip_from 198.41.128.0/17;
    set_real_ip_from 162.158.0.0/15;
    set_real_ip_from 104.16.0.0/13;
    set_real_ip_from 104.24.0.0/14;
    set_real_ip_from 172.64.0.0/13;
    set_real_ip_from 131.0.72.0/22;

    # Use Cloudflare's header for real IP
    real_ip_header CF-Connecting-IP;

    # Define the log format at the http level
    log_format custom_combined '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_real_ip" "$http_host"';

    server {
        listen 3019; 
        server_name _;

        root /usr/local/openresty/nginx/html;
        index index.html;

        location /create-preview {
            content_by_lua_block {
                local cjson = require("cjson")
                local ngx_shared = ngx.shared.site_previews

                -- Read POST data
                ngx.req.read_body()
                local body_data = ngx.req.get_body_data()

                -- Log the raw body data for debugging
                ngx.log(ngx.ERR, "Raw body data: ", body_data)

                -- Parse the body data manually
                local args = {}
                for key, value in string.gmatch(body_data, "Content%-Disposition: form%-data; name=\"([^\"]+)\"\r\n\r\n([^\r\n]+)") do
                    args[key] = value
                end

                -- Log the incoming arguments for debugging
                ngx.log(ngx.ERR, "Received arguments: ", cjson.encode(args))

                -- Validate input
                local domain = args["domain"]
                local ip = args["ip"]
                if not domain or not ip then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say("Error: Missing domain or IP Address")
                    return
                end

                ngx.log(ngx.ERR, "Domain: ", domain, ", IP: ", ip)  -- Log the domain and IP

                -- Generate a unique subdomain (e.g., preview1234.previewsites.dev)
                local preview_id = tostring(math.random(1000,9999))
                local subdomain = "preview" .. preview_id .. ".previewsites.dev"

                -- Store subdomain-IP mapping and domain in shared memory with 3-hour TTL
                local success, err = ngx_shared:set(subdomain, ip, 120)
                if not success then
                    ngx.log(ngx.ERR, "Failed to store subdomain mapping: ", err)  -- Log the error
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say("Error: Unable to store subdomain mapping: ", err)
                    return
                end

                -- Store the domain in shared memory
                success, err = ngx_shared:set(subdomain .. "_domain", domain, 120)
                if not success then
                    ngx.log(ngx.ERR, "Failed to store domain mapping: ", err)  -- Log the error
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say("Error: Unable to store domain mapping: ", err)
                    return
                end

                -- Add the subdomain to CF via API
                local http = require("resty.http")
                local httpc = http.new()
                local cf_api_url = "https://api.cloudflare.com/client/v4/zones/Zone_ID/dns_records"
                local cf_api_key = "CF_API_KEY"
                -- local cf_email = "CF_EMAIL"

                local res, err = httpc:request_uri(cf_api_url, {
                    method = "POST",
                    body = cjson.encode({
                        type = "A",
                        name = subdomain,
                        content = ip,
                        ttl = 3600, -- 3 hours TTL
                        proxied = false,
                    }),
                    headers = {
                        ["Authorization"] = "Bearer " .. cf_api_key,
                        ["Content-Type"] = "application/json",
                    },
                    ssl_verify = false,  -- Disable SSL verification
                })

                if not res or res.status ~=200 then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say("Error: Unable to create DNS Record in Cloudflare: ", err or res.body)
                    return
                end

                -- Respond with success
                ngx.say("Preview created: https://" .. subdomain)
            }
        }

        location /cleanup-previews {
            content_by_lua_block {
                local ngx_shared = ngx.shared.site_previews
                local keys = ngx_shared:get_keys(0)

                for _, key in ipairs(keys) do
                    local ttl = ngx_shared:ttl(key)
                    if ttl == 0 then
                        -- Delete the subdomain in CF
                        local http = require("resty.http")
                        local httpc = http.new()
                        local cf_api_url = "https://api.cloudflare.com/client/v4/zones/Zone_ID/dns_records"
                        local cf_api_key = "CF_API_KEY"

                        local res, err = httpc:request_uri(cf_api_url, {
                            method = "DELETE",
                            headers = {
                                ["Authorization"] = "Bearer " .. cf_api_key,
                                ["Content-Type"] = "application/json",
                            },
                        })

                        if res and res.status == 200 then
                            ngx_shared:delete(key)  -- Delete the expired subdomain from shared memory
                        end
                    end
                end

                ngx.say("Expired previews cleaned up.")
            }
        }
    }
    # Proxy requests for preview subdomains
    server {
        listen 3019;
        server_name ~^preview\d+\..+$;

        location / {
            content_by_lua_block {
                local ngx_shared = ngx.shared.site_previews
                local subdomain = ngx.var.host
                local ip = ngx_shared:get(subdomain)
                local domain = ngx_shared:get(subdomain .. "_domain")  -- Retrieve the domain

                -- Log the retrieved IP and domain for debugging
                ngx.log(ngx.ERR, "Retrieved IP: ", ip, ", Domain: ", domain)

                if not ip or not domain then
                    ngx.status = ngx.HTTP_NOT_FOUND
                    ngx.say("Error: Subdomain not found or expired.")
                    return
                end

                ngx.var.target = ip
                ngx.var.domain = domain  -- Set the domain variable
            }

            set $target ""; # Declare the variable
            set $domain "";
            rewrite_by_lua_block {
                local ngx_shared = ngx.shared.site_previews
                local subdomain = ngx.var.host
                local ip = ngx_shared:get(subdomain)
                local domain = ngx_shared:get(subdomain .. "_domain")  -- Retrieve the domain

                -- Log the retrieved IP and domain for debugging
                ngx.log(ngx.ERR, "Rewrite phase - Retrieved IP: ", ip, ", Domain: ", domain)

                if ip then
                    ngx.var.target = ip
                end

                if domain then
                    ngx.var.domain = domain  -- Set the domain variable
                end
            }

            # Proxy the request to the target IP while keeping the original URL
            proxy_pass http://$target;
            proxy_ssl_server_name on;

            # Set headers to maintain the original request information
            proxy_set_header Host $domain;  # Set the Host header to the domain from shared memory
            proxy_set_header X-Real-IP $remote_addr;  # Pass the real client IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # Forward the original IP
            proxy_set_header X-Forwarded-Proto $scheme;  # Forward the original protocol (http or https)

            # Log the headers to stdout
            access_log /usr/local/openresty/nginx/logs/access.log custom_combined;  # Log to stdout
        }
    }
} 